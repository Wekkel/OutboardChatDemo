// ============================================================================
// MainWindow.xaml.cs - The Main Window Code-Behind
// ============================================================================
//
// WHAT IS A CODE-BEHIND FILE?
// ----------------------------
// In WPF (Windows Presentation Foundation), every XAML file can have a
// "code-behind" file. The XAML defines what the window LOOKS like (buttons,
// text boxes, colors), while the code-behind handles what HAPPENS when
// you interact with it (clicking buttons, typing text).
//
// Think of it like this:
// - XAML = the blueprint of a house (where walls, doors, windows go)
// - Code-behind = the instructions for what happens when you open a door
//
// WHY IS THIS FILE SO SMALL?
// ---------------------------
// We're using the MVVM pattern (Model-View-ViewModel), which means most of
// the "brains" of our app live in the ViewModel (MainViewModel.cs), not here.
// This file only handles things that MUST happen in the window itself, like
// scrolling the chat and handling keyboard input.
// ============================================================================

using OutboardChatDemo.ViewModels;
using System;
using System.Collections.Specialized;
using System.Windows;
using System.Windows.Input;

namespace OutboardChatDemo;

/// <summary>
/// The main window of our chat application.
/// This is the "code-behind" for MainWindow.xaml - it handles window-specific
/// behavior that can't easily be done in XAML or the ViewModel.
/// </summary>
public partial class MainWindow : Window
{
    /// <summary>
    /// Constructor - runs when the window is created.
    /// Sets up the window and connects it to its ViewModel.
    /// </summary>
    public MainWindow()
    {
        // InitializeComponent() is auto-generated by WPF.
        // It reads MainWindow.xaml and creates all the visual elements
        // (buttons, text boxes, etc.) defined there.
        InitializeComponent();

        // Create our ViewModel and set it as the DataContext.
        // DataContext is WPF's way of saying "this is where the data comes from".
        // All the {Binding ...} expressions in the XAML will look here for data.
        DataContext = new MainViewModel();

        // The "Loaded" event fires after the window is fully created and visible.
        // We use it to set up our message collection listener.
        // The (_, __) syntax means "I don't care about the event parameters".
        Loaded += (_, __) =>
        {
            // Make sure our DataContext is actually a MainViewModel
            // (it should be, since we just set it, but it's good practice to check)
            if (DataContext is MainViewModel vm)
            {
                // Subscribe to the Messages collection's CollectionChanged event.
                // This fires whenever a message is added or removed from the chat.
                // We use this to auto-scroll to new messages.
                vm.Messages.CollectionChanged += Messages_CollectionChanged;
            }
        };
    }

    /// <summary>
    /// Called whenever the Messages collection changes (new message added, etc.)
    /// We use this to auto-scroll the chat to show the newest message.
    /// </summary>
    private void Messages_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        // Dispatcher.BeginInvoke schedules code to run on the UI thread.
        //
        // WHY DO WE NEED THIS?
        // WPF updates the screen in "batches" for performance. When a new message
        // is added, the visual update (adding the chat bubble) might not happen
        // instantly. If we try to scroll immediately, we might scroll before
        // the new message is visible!
        //
        // BeginInvoke says "run this code AFTER the current UI updates are done".
        // This ensures the new chat bubble exists before we try to scroll to it.
        Dispatcher.BeginInvoke(
            new Action(() =>
            {
                // Scroll the chat window to the bottom to show the newest message
                ChatScrollViewer?.ScrollToEnd();

                // Move focus back to the input box so the user can keep typing
                // without having to click on it. Nice quality-of-life feature!
                UserInputBox?.Focus();
            })
        );
    }

    /// <summary>
    /// Handles keyboard input in the message text box.
    /// We use this to send messages when the user presses Enter.
    /// </summary>
    private void UserInputBox_KeyDown(object sender, KeyEventArgs e)
    {
        // Check if the pressed key is Enter
        if (e.Key == Key.Enter)
        {
            // Try to get our ViewModel and check if we can send a message
            if (DataContext is MainViewModel vm && vm.SendCommand?.CanExecute(null) == true)
            {
                // Execute the send command (same as clicking the Send button)
                vm.SendCommand.Execute(null);

                // Mark the event as "handled" so WPF doesn't do anything else
                // with this Enter keypress (like inserting a newline)
                e.Handled = true;
            }
        }
    }
}
